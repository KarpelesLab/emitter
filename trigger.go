package emitter

import (
	"reflect"
	"sync"
	"sync/atomic"
)

// Trigger is a simple lightweight process for sending simple one shot notifications on
// multiple channels. There is no event or notification content, just a "wake up" signal
// sent to many channels at the same time. Calling the trigger costs virtually nothing
// while listeners can have more complex logic.
type Trigger struct {
	Cap    uint // capacity for channels generated by Trigger.Listen
	l      sync.RWMutex
	c      *sync.Cond
	closed uint32
	ch     map[<-chan struct{}]chan struct{}
	chLk   sync.RWMutex
}

// TriggerListener represents a listener that will receive notifications when the trigger
// is pushed. Call Release() after using it to close the channel (with a defer l.Release())
type TriggerListener struct {
	C <-chan struct{}
	t *Trigger
}

// NewTrigger returns a new trigger object ready for use. This will also create a goroutine
func NewTrigger() *Trigger {
	tr := &Trigger{
		ch: make(map[<-chan struct{}]chan struct{}),
	}
	tr.c = sync.NewCond(tr.l.RLocker())
	go tr.thread()
	return tr
}

// Push will wake all the listeners for this trigger
func (t *Trigger) Push() {
	t.c.Broadcast()
}

// Close will close all the listeners for this trigger
func (t *Trigger) Close() error {
	atomic.AddUint32(&t.closed, 1)
	t.Push()
	return nil
}

func (t *Trigger) Listen() *TriggerListener {
	c := make(chan struct{}, t.Cap)
	res := &TriggerListener{
		C: c,
		t: t,
	}

	t.chLk.Lock()
	defer t.chLk.Unlock()
	t.ch[c] = c
	return res
}

// Release will close the channel linked to this trigger and stop sending it messages
func (tl *TriggerListener) Release() {
	t := tl.t
	t.chLk.Lock()
	defer t.chLk.Unlock()
	c := t.ch[tl.C]
	delete(t.ch, tl.C)
	close(c)
}

var emptyStructVal = reflect.ValueOf(struct{}{})

func (t *Trigger) makeCases() []reflect.SelectCase {
	t.chLk.RLock()
	defer t.chLk.RUnlock()

	res := make([]reflect.SelectCase, len(t.ch)+1)
	res[0].Dir = reflect.SelectDefault

	n := 1

	for _, l := range t.ch {
		res[n].Dir = reflect.SelectSend
		res[n].Chan = reflect.ValueOf(l)
		res[n].Send = emptyStructVal
		n += 1
	}

	return res
}

func (t *Trigger) emit() {
	cases := t.makeCases()
	cnt := len(cases) - 1 // number of sends we expect, considering cases[0] is reserved for context timeout

	for {
		// (chosen int, recv Value, recvOK bool)
		chosen, _, _ := reflect.Select(cases)
		if chosen == 0 {
			// default
			return
		}
		cnt -= 1
		if cnt == 0 {
			// all sends completed successfully
			return
		}
		// set to nil & continue
		cases[chosen].Chan = reflect.Value{}
	}
}

func (t *Trigger) thread() {
	t.l.RLock()
	defer t.l.RUnlock()

	for {
		t.c.Wait()
		if atomic.LoadUint32(&t.closed) != 0 {
			// closing!
			t.chLk.Lock()
			defer t.chLk.Unlock()
			for _, c := range t.ch {
				close(c)
			}
			clear(t.ch)
			return
		}
		t.emit()
	}
}
